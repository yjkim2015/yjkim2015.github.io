---
title: 디자인패턴이란?
categories:
- DesignPattern
toc: true
toc_sticky: true
toc_label: 목차
---



## 디자인 패턴(Design Pattern)이란?

##### 소프트웨어 디자인 패턴은 소프트웨어 공학의 소프트웨어 디자인에서 특정 문맥에서 공통적으로 발생하는 문제에 대해 재사용 가능한 해결책이다.

##### 소스나 기계 코드로 바로 전환될수 있는 완성된 디자인은 아니며, 다른 상황에 맞게 사용될 수 있는 문제들을 해결하는데에 쓰이는 서술이나 템플릿이다.



**그렇다면 디자인패턴을 왜 쓸까?** 

~~솔직히 필자도 처음엔 이거 왜해 라고 생각해봤다~~.. 지금은 아니다..

<span style="color:red;">why?</span>

**디자인 패턴은 설계자로 하여금 재사용이 가능한 설계는 선택하고, 재사용을 방해하는 설계는 배제하도록 도와준다.**

**또한  패턴을 쓰면 이미 만든 시스템의 유지보수나 문서화도 개선할 수 있고, 클래스의 명세도 정확하게 할 수 있으며, 객체간의 상호작용 또는 설계 의도까지 명확하게 정의할 수 있다.**

<hr>

#### 디자인 패턴구조

* ***콘텍스트(Context)***
  * *문제가 발생하는 여러상황. 즉, 패턴이 적용 될 수 있는 상황을 말한다.*

* ***문제(Problem)***
  * *패턴이 적용되어 해결될 필요가 있는 여러 디자인 이슈들을 말한다.*
  * *이때 여러 제약 사항과 영향력도 문제 해결을 위해 고려해야한다.*
* ***해결(Solution)***
  * 문제를 해결하도록 설계를 구성하는 요소들과 그 요소들 사이의 관계, 책임, 협력 관계를 말한다.
  * *해결은 반드시 구체적인 구현 방법이나 언어에 의존적이지 않으며 다양한 상황에 적용할 수 있는 일종의 템플릿*

<hr>

디자인 패턴 계의 교과서로 불리는 **[GOF의 디자인패턴]**에서는 객체지향적 디자인 패턴의 카테고리를 다음과 같이 3가지로 구분하고 있다.



<span style="color:red;">필자는 기억을 위해 몇 줄 요약을 즐기는 편이다. 아래의 패턴들에 대해 몇줄 요약을 작성 후 이후 포스팅에서 하나씩 자세히 설명하겠다.</span>

<hr>

* **생성(Creational) 패턴**  -> 생성 패턴은 인스턴스를 만드는 절차를 추상화 하는 패턴이다.
  * *Singleton*
    * *프로그램 시작부터 종료 시까지 어떤 클래스의 인스턴스가 메모리 상에 단 하나만 존재할 수 있게 하고 이 인스턴스에 대해 어디에서나 접근할 수 있도록 하는 패턴*
  * *Abstract Factory*
    * *구체적인 클래스에 의존하지 않고 서로 연관되거나 의존적인 객체들의 조합을 만드는 인터페이스를 제공하는 패턴*
  * *Factory Method*
    * *여러개의 서브 클래스를 가진 슈퍼 클래스가 있을 때 인풋에 따라 하나의 자식 클래스의 인스턴스를 리턴해주는 패턴*
  * *Builder*
    * *복합 객체의 생성 과정과 표현 방법을 분리하여 동일한 생성 절차에서 서로 다른 표현 결과를 만들 수 있게 하는 패턴*
  * *Prototype* 
    * *객체를 생성하는데 비용(시간과 자원)이 많이 들고, 비슷한 객체가 이미 있는 경우에 사용되는 생성 패턴*

* ***구조(Structural) 패턴** -> 작은 클래스들을 상속과 합성을 이용하여 더 큰 클래스를 생성하는 방법을 제공하는 패턴이다.*
  * *Adapter*
    * *클래스의 인터페이스를 사용자가 기대하는 인터페이스 형태로 변환시키는 패턴*
  * *Composite*
    * *객체들의 관계를 상하[트리]구조로 구성하여 부분-전체 계층을 표현하는 패턴*
  * *Decorator*
    * *상속과 합성을 사용하여 객체에 동적으로 책임을 추가할 수 있게 하는 패턴*
  * *Facade*
    * *클라이언트가 쉽게 시스템과 상호 작용 할 수 있도록 도와주는 고수준의 인터페이스를 정의하고 제공하는 패턴*
  * *Flyweight*
    * *공유(Sharing)을 통하여 대량의 객체들을 효과적으로 지원하는 패턴*
  * *Proxy*
    * *어떤 다른 객체로 접근하는 것을 통제하기 위해서 그 객체의 대리자(surrogate)나 자리표시자(placeholder)의 역할을 하는 객체를 제공하는 패턴*
  * *Bridge*
    * *추상화를 구현으로부터 분리하여 각각 독립적으로 변화할 수 있도록 하는 패턴*

* ***행동 (Behaviral) 패턴***
  * *Chain Of Responsibility*
    * *책임들이 연결되어 있어 자기가 책임을 못 질 것 같으면 다음 책임자에게 자동으로 넘어가는 패턴*
  * *Command*
    * *명령어를 각각 구현하는 것보다는 하나의 추상 클래스에 메서드를 하나 만들고 각 명령이 들어오면 그에 맞는 서브클래스가 선택되어 실행되는 패턴*
  * *Interpreter*
    * *문법 규칙을 클래스화한 구조를 갖는 SQL 언어나 통신 프로토콜 같은 것을 개발할 때 사용하는 패턴.*
  * *Iterator*
    * *반복이 필요한 자료구조를 모두 동일한 인터페이스를 통해 접근할 수 있도록 메서드를 이용해 자료구조를 활용 할 수 있도록 해주는 패턴*
  * *Mediator*
    * *클래스간의 복잡한 상호작용을 캡슐화하여 한 클래스에 위임하여 처리하는 패턴*
  * *Memento*
    * Save 기능 즉,  Ctrl + z와 같은 기능 개발할 때 유용한 디자인 패턴
  * *Observer*
    * *어떤 클래스에 변화가 일어났을 때, 이를 감지하여 다른 클래스에 통보해주는 패턴.*
  * *State*
    * 동일한 동작을 객체의 상태에 따라 다르게 처리해야 할 때 사용하는 패턴
  * *Strategy*
    * 알고리즘 군을 정의하고 각각 하나의 클래스로 캡슐화한 다음, 필요할 때 서로 교환해서 사용할 수 있게 해주는 패턴
  * *Template Method*
    * 상위 클래스에서는 추상적으로 표현하고 그 구체적인 내용은 하위클래스에서 결정하는 패턴.

<hr>



